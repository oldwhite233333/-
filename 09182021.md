刷题日记 2021 09 18

# [91. 解码方法](https://leetcode-cn.com/problems/decode-ways/)

差点没写出来哈。。。

```python
class Solution:
    def numDecodings(self, s: str) -> int:
        a = 1
        b = c = 0
        n = len(s)
        for i in range(1, n + 1):
            c = 0
            if s[i - 1] != '0':
                c += a
            if i != 1 and s[i - 2] != '0' and int(s[i - 2:i]) < 27:
                c += b
            a, b = c, a
        return a
```

# [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

大道至简啊。

原来有个条件加不加都可以哈。。。

```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []
        candidates.sort()
        def helper(candidates, cur, target):
            nonlocal res
            if sum(cur) == target:
                res.append(cur)
                return
            if sum(cur) > target:
                return
            n = len(candidates)
            for i in range(n):
                if i != 0 and candidates[i] == candidates[i - 1]:
                    continue
                helper(candidates[i:], cur + [candidates[i]], target)
            return
        helper(candidates, [], target)
        return res
```

# [450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)

找前置节点或者后置节点

冲

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:
        if not root:return None
        def pre_node(root):
            while root.right:
                root = root.right
            return root
        def suc_node(root):
            while root.left:
                root = root.left
            return root
        if key > root.val:
            root.right = self.deleteNode(root.right, key)
        elif key < root.val:
            root.left = self.deleteNode(root.left, key)
        else:
            if not root.left and not root.right:return None
            if root.left:
                node = pre_node(root.left)
                root.val = node.val
                root.left = self.deleteNode(root.left, node.val)
            else:
                node = suc_node(root.right)
                root.val = node.val
                root.right = self.deleteNode(root.right, node.val)
        return root
```

# [146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)

一遍过的起飞兄弟

```python
class Node:
    def __init__(self, key = 0, value = 0):
        self.key = key
        self.value = value
        self.prev = self.next = None
    def insert(self, node):
        node.next = self.next
        node.prev = self
        self.next.prev = node
        self.next = node
def init_list():
    head = Node()
    tail = Node()
    head.next = head.prev = tail
    tail.next = tail.prev = head
    return [head, tail]
class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.curcap = 0
        self.db_list = init_list()
        self.key_node = {}

    def del_node(self, node):
        if not node.prev:return
        node.prev.next = node.next
        node.next.prev = node.prev
        return
    def up_node(self, node):
        head, _ = self.db_list
        self.del_node(node)
        head.insert(node)
        return
    def get(self, key: int) -> int:
        if key not in self.key_node:
            return -1
        node = self.key_node[key]
        self.up_node(node)
        return node.value

    def put(self, key: int, value: int) -> None:
        if key in self.key_node:
            node = self.key_node[key]
            self.up_node(node)
            node.value = value
            return
        if self.curcap == self.capacity:
            self.curcap -= 1
            _, tail = self.db_list
            node = tail.prev
            self.del_node(node)
            self.key_node.pop(node.key)
        self.curcap += 1
        node = Node(key, value)
        self.up_node(node)
        self.key_node[key] = node
        return


# Your LRUCache object will be instantiated and called as such:
# obj = LRUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)
```

# [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

排列相关的一定要记得sort 啊

```python
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        res = []
        n = len(nums)
        nums.sort()
        def helper(cur, nums):
            nonlocal res
            if not nums:
                res.append(cur)
            n = len(nums)
            for i in range(n):
                if i != 0 and nums[i] == nums[i - 1]:
                    continue
                helper(cur + [nums[i]], nums[:i] + nums[i + 1:])
            return
        helper([], nums)
        return res
```

# [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

就是用dfs 就好了

```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        res = []
        def dfs(l, r, cur):
            if r > l:return
            if l > n:return
            if l == r == n:
                res.append(cur)
                return
            dfs(l + 1, r, cur + '(')
            dfs(l, r + 1, cur + ')')
            return
        dfs(0, 0, '')
        return res
```

# [207. 课程表](https://leetcode-cn.com/problems/course-schedule/)

图论相关

检测每个class的degree 最后是否为0

```python
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        class_degree = [0] * numCourses
        after_class = [set() for _ in range(numCourses)]
        for after, pre in prerequisites:
            class_degree[after] += 1
            after_class[pre].add(after)
        stack = []
        for i in range(numCourses):
            if class_degree[i] == 0:
                stack.append(i)
        res = 0
        while stack:
            finish_class = stack.pop()
            res += 1
            for after in after_class[finish_class]:
                class_degree[after] -= 1
                if class_degree[after] == 0:
                    stack.append(after)
        return res == numCourses
```

# [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

直接就起飞不太好吧

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        dp = {}
        left = 0
        res = 0
        for r, v in enumerate(s):
            left = max(dp.get(v, left), left)
            dp[v] = r + 1
            res = max(res, r - left + 1)
        return res
```

# [138. 复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer/)

差点给我整懵了哈

```python
"""
# Definition for a Node.
class Node:
    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):
        self.val = int(x)
        self.next = next
        self.random = random
"""

class Solution:
    def copyRandomList(self, head: 'Node') -> 'Node':
        dp = {}
        def dfs(head):
            if not head:return None
            if dp.get(head, None):
                return dp[head]
            node = Node(head.val)
            dp[head] = node
            node.next = dfs(head.next)
            node.random = dfs(head.random)
            return node
        return dfs(head) 
        
```

# [240. 搜索二维矩阵 II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)

右上角看就是一个二叉树呗

```python
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        y = len(matrix[0]) - 1
        x = 0
        n = len(matrix)
        m = len(matrix[0])
        while True:
            if not (0 <= x < n and 0 <= y < m):return False 
            if matrix[x][y] == target:
                return True
            elif target > matrix[x][y]:
                x += 1
            else:
                y -= 1
        return False
```

# [15. 三数之和](https://leetcode-cn.com/problems/3sum/)

切记排序！

拍完序以后就左右指针就好了

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        res = []
        n = len(nums)
        for i, v in enumerate(nums):
            if v > 0:break
            if i != 0 and nums[i - 1] == nums[i]:
                continue
            l = i + 1
            r = n - 1
            while l < r:
                tmp = [v, nums[l], nums[r]]
                if sum(tmp) ==  0:
                    res.append(tmp)
                    l += 1
                    r -= 1
                    while l < r and nums[l] == nums[l - 1]:
                        l += 1
                    while l < r and nums[r] == nums[r + 1]:
                        r -= 1
                elif sum(tmp) > 0:
                    r -= 1
                elif sum(tmp) < 0:
                    l += 1
        return res
```

# [468. 验证IP地址](https://leetcode-cn.com/problems/validate-ip-address/)

这题是真的好烂

烂的一批的烂题

```python
class Solution:
    def validIPAddress(self, IP: str) -> str:
        def checkIPV4(s):
            s = s.split('.')
            if len(s) != 4:return False
            for field in s:
                if not field:return False
                for c in field:
                    if not c.isdigit():
                        return False
                val = int(field)
                if val > 255 or str(val) != field:return False
            return True
        def checkIPV6(s):
            s = s.split(':')
            if len(s) != 8:return False
            for field in s:
                if not field:return False
                for c in field:
                    if not (c.isdigit() or c.lower() in 'abcdef'):
                        return False
                if len(field) > 4:return False
            return True
        IP = IP.strip()
        if checkIPV4(IP):return 'IPv4'
        if checkIPV6(IP):return 'IPv6'
        return 'Neither'
```

# [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

wk 我稍稍有点震惊

两次写的居然是不一样的写法？

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        l = 0
        r = len(nums) - 1
        while l <= r:
            mid = l + (r - l) // 2
            if nums[mid] == target:return mid
            if nums[mid] < nums[r]:
                if nums[mid] < target <= nums[r]:
                    l = mid + 1
                else:
                    r = mid
            else:
                if nums[l] <= target < nums[mid]:
                    r = mid
                else:
                    l = mid + 1
        return -1
```

# [152. 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)

条件判断错了哦

```python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        curmax = 1
        curmin = 1
        res = nums[0]
        for i in nums:
            if i == 0:
                res = max(0, res)
                curmax = 1
                curmin = 1
            elif i < 0:
                curmax, curmin = curmin, curmax
            curmax = max(curmax * i, i)
            curmin = min(curmin * i, i)
            res = max(res, curmax)
        return res
```

# [153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

直接找就好了

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        l = 0
        r = len(nums) - 1
        while l < r:
            mid = l + (r - l) // 2
            if nums[mid] < nums[r]:
                r = mid
            else:
                l = l + 1
        return nums[l]
```

# [36. 有效的数独](https://leetcode-cn.com/problems/valid-sudoku/)

这个真的用脚做就好了啊

```python
class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        init_set = lambda : [set() for _ in range(9)]
        rows = init_set()
        cols = init_set()
        boxes = init_set()
        box_id = lambda x, y: (x // 3) * 3 + y // 3
        for x in range(9):
            for y in range(9):
                val = board[x][y]
                if val == '.':continue
                if val in rows[x]\
                or val in cols[y]\
                or val in boxes[box_id(x, y)]:
                    return False
                rows[x].add(val)
                cols[y].add(val)
                boxes[box_id(x, y)].add(val)
        return True
```

# [1483. 树节点的第 K 个祖先](https://leetcode-cn.com/problems/kth-ancestor-of-a-tree-node/)

差点魔怔了

```python
class TreeAncestor:

    def __init__(self, n: int, parent: List[int]):
        k = int(log2(n)) + 1
        dp = [[-1] * k for _ in range(n)]
        for i in range(n):
            dp[i][0] = parent[i]
        for i in range(n):
            for j in range(1, k):
                if dp[i][j - 1] != -1:
                    dp[i][j] = dp[dp[i][j - 1]][j - 1]
        self.dp = dp

    def getKthAncestor(self, node: int, k: int) -> int:
        while node != -1 and k != 0:
            t = int(log2(k))
            node = self.dp[node][t]
            k -= 1 << t
        return node


# Your TreeAncestor object will be instantiated and called as such:
# obj = TreeAncestor(n, parent)
# param_1 = obj.getKthAncestor(node,k)
```

# [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

马拉车马拉车马拉车

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        processed_string = '#'.join('$' + s + '&')
        right = center = 0
        length = len(processed_string)
        lps = [0] * length
        max_lps_length = max_lps_pos = 0
        check = lambda x: 0 < x < length
        for offset in range(1, length - 1):
            if offset < right:
                lps[offset] = min(right - offset, lps[2 * center - offset])
            while True:
                l = offset - lps[offset] - 1
                r = offset + lps[offset] + 1
                if check(l) and check(r) and processed_string[l] == processed_string[r]:
                    lps[offset] += 1
                else:
                    break
            if lps[offset] + offset > right:
                right = lps[offset] + offset
                center = offset
            if lps[offset] > max_lps_length:
                max_lps_length = lps[offset]
                max_lps_pos = offset
        start = (max_lps_pos - max_lps_length) // 2
        end = start + max_lps_length
        return s[start: end]
```

