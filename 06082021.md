今天是2021 06 08 周二 两天没刷了，这星期端午~~~ 起飞。
***
# 889. 根据前序和后序遍历构造二叉树
一开始没做出来，看了看题解后发现真的好简单。做这种题型都差不多。找到分界点递归就可以了。
***
![image](https://user-images.githubusercontent.com/84114842/121112047-76b67d80-c842-11eb-8924-d48e5d588a13.png)
![image](https://user-images.githubusercontent.com/84114842/121112063-7c13c800-c842-11eb-9827-ab9f9255f302.png)

# 515. 在每个树行中找最大值
简单题，层序遍历之后找每层最大值，秒解。
***
![image](https://user-images.githubusercontent.com/84114842/121112506-15db7500-c843-11eb-9d3a-aaf993a39108.png)
![image](https://user-images.githubusercontent.com/84114842/121112517-1aa02900-c843-11eb-98e5-65fd273d91f1.png)

# 538. 把二叉搜索树转换为累加树
简单的一批，一开始题目没看懂Orz，看了下评论后得了点思路后写出来
***
![image](https://user-images.githubusercontent.com/84114842/121113368-859e2f80-c844-11eb-947f-cacafc0a67ef.png)
![image](https://user-images.githubusercontent.com/84114842/121113374-8931b680-c844-11eb-9403-b014b63a2015.png)

# 1008. 前序遍历构造二叉搜索树
其实不难，每次构建二叉树都要想好那里分割，这里的解题关键是需要考虑到二叉树的中序的是排序递增的，然后通过前序遍历和中序遍历构造。
***
![image](https://user-images.githubusercontent.com/84114842/121114665-abc4cf00-c846-11eb-9662-cff1ee0e1415.png)
![image](https://user-images.githubusercontent.com/84114842/121114677-af585600-c846-11eb-890b-07b48ee254bb.png)

# 222. 完全二叉树的节点个数
诈眼一看觉得太鸡儿简单了把，看了下题解觉得还是太年轻了，没用到完全二叉树的特点。就这样先。但其实一开始有想用层序遍历？？
![image](https://user-images.githubusercontent.com/84114842/121117507-d2850480-c84a-11eb-99d0-4bc584b53703.png)
![image](https://user-images.githubusercontent.com/84114842/121117515-d57ff500-c84a-11eb-822d-f572397f0777.png)

# 863. 二叉树中所有距离为 K 的结点
感觉挺简单的其实。一开始写的时候忘记要阻止它回头递归了。。。。
***
![image](https://user-images.githubusercontent.com/84114842/121119621-889e1d80-c84e-11eb-99cb-9be087ce8ad0.png)
```py
class Solution:
    def distanceK(self, root: TreeNode, target: TreeNode, k: int) -> List[int]:
        parent={}
        def traverse(root,target):
            if not root:return
            if root.val ==target.val:return
            if root.left:
                parent[root.left]=root
                traverse(root.left,target)
            if root.right:
                parent[root.right]=root
                traverse(root.right,target)
        traverse(root,target)
        res=[]
        def getdistance(root,target,k):
            if not root:return
            if k == 0:
                nonlocal res
                res.append(root.val)
                return
            if root.left and root.left.val!=target.val:
                getdistance(root.left,root,k-1)
            if root.right and root.right.val!= target.val:
                getdistance(root.right,root,k-1)
            if parent.get(root,None) != None and parent[root].val!=target.val:
                getdistance(parent[root],root,k-1)
            return
        getdistance(target,target,k)
        return res
