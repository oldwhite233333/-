08 13 2021 刷题日记
感觉二分法相关的都没有那么简单啊
都是必须要考虑好一些比较细节的地方
话说今天周五。
# 153. 寻找旋转排序数组中的最小值
> https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/
做了一次又一次， 跪了一次又一次，这题属实不太容易啊
```py
class Solution:
    def findMin(self, nums: List[int]) -> int:
        l ,r = 0, len(nums) - 1
        while l < r:
            pivot = l + (r - l) // 2
            if nums[pivot] < nums[r]:
                r = pivot
            else:
                l = pivot + 1
        return nums[l]
```
# 162. 寻找峰值
> https://leetcode-cn.com/problems/find-peak-element/
属实不太容易加一，但是发现二分法的题都是先确定右边边界，然后逐步缩进右边边界
```py
class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        l, r = 0, len(nums) - 1
        while l < r:
            mid = (l + r) // 2
            if nums[mid] > nums[mid + 1]:
                r = mid
            else:
                l = l + 1
        return l
```
# 152. 乘积最大子数组
> https://leetcode-cn.com/problems/maximum-product-subarray/
这题感觉没啥问题了~
```py
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        res = nums[0]
        curmax = curmin = 1
        for i in nums:
            if i == 0:
                curmax = curmin = 1
                res = max(res, 0)
                continue
            elif i < 0:
                curmax, curmin = curmin,curmax
            curmax = max(i, curmax * i)
            curmin = min(i, curmin * i)
            res = max(res, curmax)
        return res
```
# 15. 三数之和
> https://leetcode-cn.com/problems/3sum/
md 坑好多啊，有点顶不住啊
```py
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        res = []
        nums.sort()
        for i, v in enumerate(nums):
            if v > 0:
                break
            if i != 0 and nums[i] == nums[i - 1]:
                continue
            l, r = i + 1, len(nums) - 1
            while l < r:
                if v + nums[l] + nums[r] == 0:
                    res.append([v, nums[l], nums[r]])
                    l += 1
                    r -= 1
                    while l < r and nums[l] == nums[l - 1]:
                        l += 1
                    while l < r and nums[r] == nums[r + 1]:
                        r -= 1 
                elif v + nums[l] + nums[r] < 0:
                    l += 1
                else:
                    r -= 1
        return res
```

















