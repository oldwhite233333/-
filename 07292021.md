2021 07 29 
提高专注能力很重要 很多的时候就是这些专注的能力让我们更加容易成功
减少心理entropy 熵
# 253. 会议室 II
> https://leetcode-cn.com/problems/meeting-rooms-ii/
一道用优先队列(或者是大小堆) 完成的题目
首先把所有的会议都用开始时间排序。然后创建一个优先队列。
然后遍历所有的会议，在开始时间小于结束时间时，pop出来再添加。其他的就直接添加。
```py
    def minMeetingRooms(self, intervals: List[List[int]]) -> int:
        intervals.sort(key=lambda x:x[0])
        freelist = [intervals[0][1]]
        for i in range(1,len(intervals)):
            if intervals[i][0]>=freelist[0]:
                heapq.heappop(freelist)
            heapq.heappush(freelist,intervals[i][1])
        return len(freelist)
```
# 692. 前K个高频单词
> https://leetcode-cn.com/problems/top-k-frequent-words/
发现直接用排序来操作可以非常的优雅
```py
    def topKFrequent(self, words: List[str], k: int) -> List[str]:
        freq = collections.Counter(words)
        res = sorted(freq,key = lambda word:(-freq[word],word))
        return res[:k]
```
还有一种做法是用堆直接算，因为python都是最小堆所以要取反。
```py
    def topKFrequent(self, words: List[str], k: int) -> List[str]:
        freq = collections.Counter(words)
        heap = []
        for key,value in freq.items():
            heapq.heappush(heap,(-value,key))
        res = []
        for _ in range(k):
            res.append(heapq.heappop(heap)[1])
        return res
```
# 1249. 移除无效的括号
> https://leetcode-cn.com/problems/minimum-remove-to-make-valid-parentheses/
说真的比我想象中要简单的多诶。。。不是特别复杂的题目
就首先维护一个stack然后当不匹配的时候放进去同时记录下坐标。
```py
    def minRemoveToMakeValid(self, s: str) -> str:
        res = [i for i in s]
        stack = []
        for i in range(len(res)):
            if res[i] == '(':
                stack.append(('(',i))
            elif res[i] == ')':
                if stack and stack[-1][0]=='(':
                    stack.pop()
                    continue
                stack.append((')',i))
            else:
                continue
        for i in stack:
            res[i[1]]=''
        return ''.join(res)
```
# 1. 两数之和
> https://leetcode-cn.com/problems/two-sum/
没想到两数之和这么经典的题目居然是第一题
```py
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        hashmap = {}
        for i in range(len(nums)):
            hashmap[nums[i]] = i
        for i in range(len(nums)):
            if hashmap.get(target-nums[i],-1) != -1:
                if i != hashmap[target-nums[i]]:
                    return [i,hashmap[target-nums[i]]]
        return [-1,-1]
```
# 49. 字母异位词分组
> https://leetcode-cn.com/problems/group-anagrams/
这里用了个质数的方法。所有质数的相乘都具有唯一性，所以如果两个词的质数值相等则词为异位
```py
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        k = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101]
        letters = {}
        for i in range(26):
            letters[chr(ord('a')+i)] = k[i]
        def word2number(word):
            nonlocal letters
            res = 1
            for i in word:
                res*=letters[i]
            return res
        group = {}
        for i in strs:
            k = word2number(i)
            print(k)
            group[k] = group.get(word2number(i),[])
            group[k].append(i)
        return [i[1] for i in group.items()]
```
但感觉不够优雅。
看了个题解的。还算比较优雅。
原来还能有 collections.defaultdict(list) 这种写法。震惊
可以直接返回默认值
```py
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        mp = collections.defaultdict(list)
        print(mp)
        for st in strs:
            counts = [0] * 26
            for ch in st:
                counts[ord(ch) - ord('a')]+=1
            mp[tuple(counts)].append(st)
        return list(mp.values())
```
# 560. 和为K的子数组
> https://leetcode-cn.com/problems/subarray-sum-equals-k/
做过了 但是第一反应是左右指针诶。。。 但是如果有负数的情况的就不太好处理了
就是用哈希表记录下之前的结果。
然后叠加起来。
这样就能把负数的结果也考虑进去了。
看了题解又觉得有点迷迷糊糊啊
```py
        allsum={0:1}
        res=presum =0
        for i in nums:
            presum += i
            res += allsum.get(presum-k,0)
            allsum[presum]=allsum.get(presum,0)+1
```
# 953. 验证外星语词典
> https://leetcode-cn.com/problems/verifying-an-alien-dictionary/
这个也能算easy啊沃日
看到有个战神的写法实在是太优雅了
淦
```py
    def isAlienSorted(self, words: List[str], order: str) -> bool:
        return words == sorted(words, key= lambda s:''.join(['abcdefghijklmnopqrstuvwxyz'[order.index(i)] for i in s]))
```
# 98. 验证二叉搜索树
> https://leetcode-cn.com/problems/validate-binary-search-tree/
这题难度不是直接用脚写？
直接中序遍历然后就完事了
```py
    def isValidBST(self, root: TreeNode) -> bool:
        res = []
        def traverse(root):
            if not root:return
            traverse(root.left)
            res.append(root.val)
            traverse(root.right)
            return
        traverse(root)
        for i in range(1,len(res)):
            if res[i-1]>=res[i]:
                return False
        return True
```
看题解写了个递归的。比较烦的是不能直接判断上界和下界,必须要用无穷来算
```py
    def isValidBST(self, root: TreeNode) -> bool:
        def traverse(root,lower=float('-inf'),upper=float('inf')):
            if not root:return True
            if not lower<root.val<upper:
                return False
            if not traverse(root.left,lower,root.val):return False
            if not traverse(root.right,root.val,upper):return False
            return True
        return traverse(root)
```
# 124. 二叉树中的最大路径和
> https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/
一看到hard 就知道可能不是这么好写出来 但是感觉好像又不是那么的难
```py
    def maxPathSum(self, root: TreeNode) -> int:
        res = -999999
        def traverse(root):
            if not root:return 0
            left = traverse(root.left)
            right = traverse(root.right)
            val = root.val
            nonlocal res
            res = max(left+right+val,res)
            return max(0,max(left,right)+val)
        traverse(root)
        return res
```
# 199. 二叉树的右视图
> https://leetcode-cn.com/problems/binary-tree-right-side-view/
这题不是有手就行？ 直接秒解啊hxd
```py
    def rightSideView(self, root: TreeNode) -> List[int]:
        if not root:return []
        q = [root]
        res = []
        while q:
            res.append(q[-1].val)
            for i in range(len(q)):
                p = q.pop(0)
                if p.left:
                    q.append(p.left)
                if p.right:
                    q.append(p.right)
        return res
```
看到有个递归的写法，很神奇。。。
还有第一次在python里面看到指针？？？
```py
    def rightSideView(self, root: TreeNode) -> List[int]:
        d = {}
        def f(r, i):
            if r:
                d[i] = r.val
                f(r.left, i + 1)
                f(r.right, i + 1)
        f(root, 0)
        return [*d.values()]
```
