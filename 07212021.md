还有两天周末了！！！
距离周末还有两天！！！
起飞
该去哪里玩耍啊
2021 07 21 
# 739. 每日温度
> https://leetcode-cn.com/problems/daily-temperatures/
第一次有单调栈的想法 但是很模糊。bad
估计后面做多有手感。
```py
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        l = len(temperatures)
        res = [0]*l
        stack = []
        for i in range(l):
            while stack and temperatures[i]> temperatures[stack[-1]]:
                t = stack.pop()
                res[t] = i-t
            stack.append(i)
        return res
```
# 701. 二叉搜索树中的插入操作
这个不是有手就行？
> https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/
```py
    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:
        if not root:
            return TreeNode(val)
        if root.val > val:
            if root.left:
                self.insertIntoBST(root.left,val)
            else:
                root.left=self.insertIntoBST(root.left,val)
        else:
            if root.right:
                self.insertIntoBST(root.right,val)
            else:
                root.right=self.insertIntoBST(root.right,val)
        return root
```
# 剑指 Offer 33. 二叉搜索树的后序遍历序列
这题做过了 但是居然要看之前的题解才能做出来。 Orz
就是 二叉树的概念和后序遍历的概念一定想清楚！
> https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/
```py
    def verifyPostorder(self, postorder: List[int]) -> bool:
        def dfs(postorder):
            l = len(postorder)
            if l <=1:
                return True
            root = postorder[-1]
            k = 0
            while postorder[k]< root and k<l:
                k+=1
            for i in range(k,l):
                if postorder[i]<root:
                    return False
            return dfs(postorder[:k]) and dfs(postorder[k:-1])
        return dfs(postorder)
```
# 139. 单词拆分
说实话 看之前的题解看到迷迷糊糊。
不能算是很会吧。
用dp做的。复杂度很高
> https://leetcode-cn.com/problems/word-break/
```py
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        l = len(s)
        dp=[False]*(l+1)
        dp[0]=True
        for i in range(l):
            for z in range(i+1,l+1):
                tmp = s[i:z]
                if dp[i] and tmp in wordDict:
                    dp[z]=True
        return dp[-1] 
```
