刷题日记 09 24 2021

今天马上就要又刷完一遍拉~

明天又要去杭州了~

# [150. 逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)

这真的不是有手就行嘛。。

```python
class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        stack = []
        for i in tokens:
            if i in '+-*/':
                a1 = stack.pop()
                a2 = stack.pop()
                i = eval(str(a2) + i + str(a1))
            stack.append(int(i))
        return sum(stack)
```

# [1375. 灯泡开关 III](https://leetcode-cn.com/problems/bulb-switcher-iii/)

真的有够弱智的诶。。

```python
class Solution:
    def numTimesAllBlue(self, light: List[int]) -> int:
        curmax = 0
        res = 0
        curnum = 0
        for i in light:
            curnum += 1
            curmax = max(curmax, i)
            if curmax == curnum:
                res += 1
        return res
```

# [662. 二叉树最大宽度](https://leetcode-cn.com/problems/maximum-width-of-binary-tree/)

大概就是看层序遍历然后看左右两边就好了

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def widthOfBinaryTree(self, root: TreeNode) -> int:
        res = 0
        q = [(root, 1)]
        while q:
            l = q[0][1]
            r = q[-1][1]
            res = max(r - l + 1, res)
            for _ in range(len(q)):
                p, step = q.pop(0)
                if p.left:
                    q.append((p.left, step * 2))
                if p.right:
                    q.append((p.right, step * 2 + 1))
        return res
```

# [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

感觉有点像个弱智题目啊

```python
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        n = len(temperatures)
        res = [0] * n
        stack = []
        for i, v in enumerate(temperatures):
            while stack and temperatures[stack[-1]] < v:
                index = stack.pop()
                res[index] = i - index
            stack.append(i)
        return res
```

# [701. 二叉搜索树中的插入操作](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)

是不是弱智

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:
        if not root:return TreeNode(val)
        if val > root.val:
            root.right = self.insertIntoBST(root.right, val)
        else:
            root.left = self.insertIntoBST(root.left, val)
        return root
```

# [139. 单词拆分](https://leetcode-cn.com/problems/word-break/)

直接冲 就完事了

```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        if not s:return False
        n = len(s)
        dp = [True] + [False] * n
        for l in range(n):
            for r in range(l + 1, n + 1):
                if dp[l] and s[l:r] in wordDict:
                    dp[r] = True
        return dp[-1]
```

