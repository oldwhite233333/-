今天是2021/06/11 刷题记录 天气晴ZZZZZZZZZZ 端午！端午！马上下班起飞！
***
# 285. 二叉搜索树中的中序后继
不知道怎么就中等难度了，中序遍历后设置一个条件不就可以了嘛。。。。。
***
> 链接：https://leetcode-cn.com/problems/inorder-successor-in-bst
```
给定一棵二叉搜索树和其中的一个节点 p ，找到该节点在树中的中序后继。如果节点没有中序后继，请返回 null 。

节点 p 的后继是值比 p.val 大的节点中键值最小的节点。
```
```py
class Solution:
    def inorderSuccessor(self, root: 'TreeNode', p: 'TreeNode') -> 'TreeNode':
        res=None
        found=False
        def traverse(root,p):
            nonlocal res
            nonlocal found
            if not root:return
            traverse(root.left,p)
            if root.val == p.val:
                found=True
            elif found==True and not res:
                res= root
            elif found == True and res:
                return
            traverse(root.right,p)
        traverse(root,p)
        return res
```
# 1448. 统计二叉树中好节点的数目
乍一看感觉挺难的。没想好怎么做，想了想后觉得不是很难，记录下path后看是不是就行了，其实还有一直做法估计是记录上一个最大的值，毕竟只是单次对比，不算很难吧。
> 链接：https://leetcode-cn.com/problems/count-good-nodes-in-binary-tree
```
给你一棵根为 root 的二叉树，请你返回二叉树中好节点的数目。

「好节点」X 定义为：从根到该节点 X 所经过的节点中，没有任何节点的值大于 X 的值。
```
```py
class Solution:
    def goodNodes(self, root: TreeNode) -> int:
        res=0
        def traverse(root,path):
            if not root:return
            nonlocal res
            tmp=path[::]
            tmp.append(root.val)
            if max(tmp)==root.val:
                res+=1
            traverse(root.left,tmp)
            traverse(root.right,tmp)
        traverse(root,[])
        return res
```
